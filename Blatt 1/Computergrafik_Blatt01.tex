\documentclass[11pt]{article}
\usepackage[ngerman]{babel}
\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3.5cm]{geometry}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{amssymb}
\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage{mathtools}
\usepackage{lipsum}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{geometry}
\usepackage[dvipsnames]{xcolor}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{tikz}
\usepackage[utf8]{inputenc}
\newcommand{\bbN}{\mathbbm{N}}
\newcommand{\bbZ}{\mathbbm{Z}}
\newcommand{\bbQ}{\mathbbm{Q}}
\newcommand{\bbR}{\mathbbm{R}}
\newcommand{\bbC}{\mathbbm{C}}
\newcommand{\bbI}{\mathbbm{I}}
\newcommand{\bigO}{\mathcal{O}}
\newcommand{\bigT}{\mathcal{T}}
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
\newcommand\abv[2]{\stackrel{\mathclap{\normalfont\mbox\tiny{#2}}}{#1}}
\newcommand\norm[1]{\left\lVert{#1}\right\rVert}
\lstset{basicstyle=\ttfamily, mathescape}
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}
\setlength{\parindent}{0 pt}
\hbadness=99999 % No fucking underfull hbox warning
\hfuzz=9999pt % No fucking overfull hbox warning
\pagestyle{fancy}
\tikzstyle{textbox} = [draw, rounded corners, minimum height=2em, minimum width=4em]
\tikzstyle{arrow} = [->, thick]
\setlength{\headheight}{42.91258pt}
\lstdefinestyle{pretty}{
  backgroundcolor=\color{gray!10},
  frame=single,
  rulecolor=\color{gray!60},
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{green!60!black}\itshape,
  stringstyle=\color{red!70!black},
  numberstyle=\tiny\color{gray},
  numbers=left,
  stepnumber=1,
  numbersep=8pt,
  tabsize=2,
  breaklines=true,
  breakatwhitespace=true,
  showstringspaces=false,
  captionpos=b
}

\lstset{style=pretty}
\lstset{escapeinside={(*@}{@*)}}

\lhead{Computergraphik\\
Wintersemester 2025/26\\
\today}
\chead{\huge\textbf{Übungsblatt 1}}
\rhead{Maximilian Peresunchak 3232875\\
Nico Reng 3731402\\
Viorel Tsigos 3720183}
\begin{document}
\section*{Aufgabe 1:}
Siehe Code

\section*{Aufgabe 2:}
\begin{enumerate}[label=2.1.\arabic*]
  \item Wir haben uns hier für den Container "Array" entschieden, da wir hier eine feste Größe bestimmen können, was in der Aufgabenstellung mit 3 Punkten vorgegeben ist. Wir haben hier auch keinen Laufzeit-Overhead also müssen wir nicth unsere Kapazität prüfen wie bei einem Vektor Container. Hierdurch haben wir mehr Leistung.
  \item Siehe Code
\end{enumerate}
\begin{enumerate}[label=2.2.\arabic*]
  \item Hier haben wir "List" als Container gewählt. Erstmals ist mit einer doppelt verketteten Liste das Einfügen und Löschen in $\bigO(1)$ möglich. Der Hauptgrund war aber, dass wenn wir einen Punkt in der List löschen, verlieren wir nicht die Referenz auf die anderen anliegenden Punkte. Bei einem Vektor z.B. würden wir die Referenz zu den anderen Punkten verlieren.  
  \item Siehe Code
\end{enumerate}
\begin{enumerate}[label=2.3.\arabic*]
  \item Hier haben wir jetzt den Container "Vector" verwendet. Wir haben hier auch wieder einen niedrigeren Overhead. Brauchen also keinen zusätzlichen Speicherplatz für einen Pointer. Wir speichern nur die Daten. Außerdem wenn wir über die Liste der Linienzüge iterieren, kann der CPU die Datenblöcke schneller abrufen und wir haben schnellere Verabeitungszeiten.
  \item Siehe Code
  \item Siehe Code
\end{enumerate}

\section*{Aufgabe 3:}
\begin{enumerate}
  \item Siehe Code
  \item Das hat mit den Referenzen zu tun. Wir befüllen ja die Matrix mit Daten aus matrix1.txt und matrix2.txt. Wir übergeben das hier als Nicht-konstante Referenz. Heißt also dass wir das Objekt MatrixInt verändern können. Dadurch entstehen keine unnötigen Kopien des Matrix-Objekts. Das würde z.B. bei ganz großen Matrizen zu hohem Speicherverbrauch führen und ggf. auch zu Performanceproblemen (Leistung fällt ab). Also Vermeidung von Kopien und durch die const ist auch sichergestellt, dass die Funktion die übergebene Matrix nicht aus Versehen verändern kann. Ein Vorteil von RAII ist die automatische Speicherverwaltung, also die automatische Freigabe einer Ressource $\Rightarrow$ weniger Ressourcenlecks.
\end{enumerate}
\section*{Aufgabe 4:}
\begin{enumerate}
  \item Siehe Code
  \item In einer .hpp dürfen nur Deklarationen stehen, keine Definitionen. Deswegen muss man eine neue Definition.hpp Datei erstellen und die Definitionen dort reinpacken. C++ erlaubt nämlich keine Mehrfachdefinitionen von Funktionen. Deshalb könnte es hier passieren, dass hier mehrere Kopien der Funktion in verschiedenen .cpp Dateien entstehen könnte.
\end{enumerate}
\section*{Aufgabe 5:}
Siehe Code
\end{document}