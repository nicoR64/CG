\documentclass[11pt]{article}
\usepackage[ngerman]{babel}
\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3.5cm]{geometry}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{amssymb}
\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage{mathtools}
\usepackage{lipsum}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{geometry}
\usepackage[dvipsnames]{xcolor}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{tikz}
\usepackage[utf8]{inputenc}
\newcommand{\bbN}{\mathbbm{N}}
\newcommand{\bbZ}{\mathbbm{Z}}
\newcommand{\bbQ}{\mathbbm{Q}}
\newcommand{\bbR}{\mathbbm{R}}
\newcommand{\bbC}{\mathbbm{C}}
\newcommand{\bbI}{\mathbbm{I}}
\newcommand{\bigO}{\mathcal{O}}
\newcommand{\bigT}{\mathcal{T}}
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
\newcommand\abv[2]{\stackrel{\mathclap{\normalfont\mbox\tiny{#2}}}{#1}}
\newcommand\norm[1]{\left\lVert{#1}\right\rVert}
\lstset{basicstyle=\ttfamily, mathescape}
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}
\setlength{\parindent}{0 pt}
\hbadness=99999 % No fucking underfull hbox warning
\hfuzz=9999pt % No fucking overfull hbox warning
\pagestyle{fancy}
\tikzstyle{textbox} = [draw, rounded corners, minimum height=2em, minimum width=4em]
\tikzstyle{arrow} = [->, thick]
\setlength{\headheight}{42.91258pt}
\lstdefinestyle{pretty}{
  backgroundcolor=\color{gray!10},
  frame=single,
  rulecolor=\color{gray!60},
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{green!60!black}\itshape,
  stringstyle=\color{red!70!black},
  numberstyle=\tiny\color{gray},
  numbers=left,
  stepnumber=1,
  numbersep=8pt,
  tabsize=2,
  breaklines=true,
  breakatwhitespace=true,
  showstringspaces=false,
  captionpos=b
}

\lstset{style=pretty}
\lstset{escapeinside={(*@}{@*)}}

\lhead{Computergraphik\\
Wintersemester 2025/26\\
\today}
\chead{\huge\textbf{Übungsblatt 1}}
\rhead{Maximilian Peresunchak 3232875\\
Nico Reng 3731402\\
Viorel Tsigos 3720183}
\begin{document}
\section*{Aufgabe 1:}
Siehe Code

\section*{Aufgabe 2:}
\begin{enumerate}[label=2.1.\arabic*]
  \item Wir haben uns hier für den Container \texttt{std::array} entschieden, da wir genau drei Koordinaten \texttt{x,y,z} abspeichern wollen. Wir haben hier auch keinen Laufzeit-Overhead, da unsere Größe zur Laufzeit nie angepasst werden muss.
  \item Siehe Code
\end{enumerate}
\begin{enumerate}[label=2.2.\arabic*]
  \item Hier haben wir \texttt{std::list} als Container gewählt. Erstmals ist mit einer doppelt verketteten Liste das Einfügen am Ende der Liste in $\bigO(1)$ möglich. Wir müssen hierfür das Löschen an einer beliebigen Position in $\bigO(n)$ in Anspruch nehmen. Dafür entstehen beim Löschen von Elementen keine Löcher im Memory-Block und wir können mit einem Iterator sauber über alle Punkte iterieren. Die Abfrage nach einzelnen Punkten muss nicht berücksichtigt werden.
  \item Siehe Code
\end{enumerate}
\begin{enumerate}[label=2.3.\arabic*]
  \item Hier haben wir den Container \texttt{std::vector} verwendet. Da wir zur Laufzeit fortlaufend neue Linienzüge hinzufügen wollen, brauchen wir eine dynamische Datenstruktur, die wachsen kann. Hierfür ist der Vector geeignet, insbesondere weil die Linienzüge nicht mehr entfernt werden sollen und wir somit immer alle Linienzüge in einem zusammenhängenden Block in Memory stehen haben.
  \item Siehe Code
  \item Siehe Code
\end{enumerate}

\section*{Aufgabe 3:}
\begin{enumerate}
  \item Siehe Code
  \item Es werden mit \texttt{\&} und \texttt{const\&} eine Referenz auf ein Matrixobjekt übergeben. Würden wir hier das Konzept der Referenz nicht verwenden, so müssten wir eine vollständige Kopie des Objekts erstellen und schließlich auf der Kopie weiterarbeiten, wobei bei großen Matrizen ein beträchtlicher Performance-Overhead entstehen kann. Zusätzlich sorgen wir mit \texttt{const} dafür, das wir die an der Referenz gespeicherte Matrix nicht durch eine andere Matrix ersetzen können und auch die eigenen Einträge der Matrix nicht anpassen dürfen. Ein Vorteil von RAII ist die automatische Speicherverwaltung, also die automatische Freigabe einer Ressource, sodass weniger Ressourcenlecks entstehen können.
\end{enumerate}
\section*{Aufgabe 4:}
\begin{enumerate}
  \item Siehe Code
  \item In einer .hpp dürfen nur Deklarationen stehen, keine Definitionen. Deswegen muss man eine neue Definition.hpp Datei erstellen und die Definitionen dort reinpacken. C++ erlaubt nämlich keine Mehrfachdefinitionen von Funktionen. Deshalb könnte es hier passieren, dass hier mehrere Kopien der Funktion in verschiedenen .cpp Dateien entstehen könnte.
\end{enumerate}
\section*{Aufgabe 5:}
Siehe Code
\end{document}
